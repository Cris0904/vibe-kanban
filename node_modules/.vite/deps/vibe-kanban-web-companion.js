import {
  require_react_dom
} from "./chunk-ZEJDETLQ.js";
import {
  __commonJS,
  __toESM,
  require_react
} from "./chunk-AQI5YXZE.js";

// node_modules/point-in-polygon/flat.js
var require_flat = __commonJS({
  "node_modules/point-in-polygon/flat.js"(exports, module) {
    module.exports = function pointInPolygonFlat(point, vs, start, end) {
      var x = point[0], y = point[1];
      var inside = false;
      if (start === void 0) start = 0;
      if (end === void 0) end = vs.length;
      var len = (end - start) / 2;
      for (var i = 0, j = len - 1; i < len; j = i++) {
        var xi = vs[start + i * 2 + 0], yi = vs[start + i * 2 + 1];
        var xj = vs[start + j * 2 + 0], yj = vs[start + j * 2 + 1];
        var intersect = yi > y !== yj > y && x < (xj - xi) * (y - yi) / (yj - yi) + xi;
        if (intersect) inside = !inside;
      }
      return inside;
    };
  }
});

// node_modules/point-in-polygon/nested.js
var require_nested = __commonJS({
  "node_modules/point-in-polygon/nested.js"(exports, module) {
    module.exports = function pointInPolygonNested(point, vs, start, end) {
      var x = point[0], y = point[1];
      var inside = false;
      if (start === void 0) start = 0;
      if (end === void 0) end = vs.length;
      var len = end - start;
      for (var i = 0, j = len - 1; i < len; j = i++) {
        var xi = vs[i + start][0], yi = vs[i + start][1];
        var xj = vs[j + start][0], yj = vs[j + start][1];
        var intersect = yi > y !== yj > y && x < (xj - xi) * (y - yi) / (yj - yi) + xi;
        if (intersect) inside = !inside;
      }
      return inside;
    };
  }
});

// node_modules/point-in-polygon/index.js
var require_point_in_polygon = __commonJS({
  "node_modules/point-in-polygon/index.js"(exports, module) {
    var pointInPolygonFlat = require_flat();
    var pointInPolygonNested = require_nested();
    module.exports = function pointInPolygon2(point, vs, start, end) {
      if (vs.length > 0 && Array.isArray(vs[0])) {
        return pointInPolygonNested(point, vs, start, end);
      } else {
        return pointInPolygonFlat(point, vs, start, end);
      }
    };
    module.exports.nested = pointInPolygonNested;
    module.exports.flat = pointInPolygonFlat;
  }
});

// node_modules/@floating-ui/react-dom-interactions/dist/floating-ui.react-dom-interactions.esm.js
var React = __toESM(require_react());
var import_react2 = __toESM(require_react());

// node_modules/@floating-ui/core/dist/floating-ui.core.esm.development.js
var sides = ["top", "right", "bottom", "left"];
var allPlacements = sides.reduce((acc, side) => acc.concat(side, side + "-start", side + "-end"), []);

// node_modules/@floating-ui/react-dom/dist/floating-ui.react-dom.esm.js
var import_react = __toESM(require_react());
var import_react_dom = __toESM(require_react_dom());

// node_modules/@floating-ui/react-dom-interactions/dist/floating-ui.react-dom-interactions.esm.js
var import_point_in_polygon = __toESM(require_point_in_polygon());
var import_react_dom3 = __toESM(require_react_dom());
var index = typeof document !== "undefined" ? import_react2.useLayoutEffect : import_react2.useEffect;
var serverHandoffComplete = false;
var count = 0;
var genId = () => "floating-ui-" + count++;
function useFloatingId() {
  const [id, setId] = React.useState(() => serverHandoffComplete ? genId() : void 0);
  index(() => {
    if (id == null) {
      setId(genId());
    }
  }, []);
  React.useEffect(() => {
    if (!serverHandoffComplete) {
      serverHandoffComplete = true;
    }
  }, []);
  return id;
}
var useReactId = React["useId".toString()];
var useId = useReactId != null ? useReactId : useFloatingId;
var FloatingNodeContext = (0, import_react2.createContext)(null);
var FloatingTreeContext = (0, import_react2.createContext)(null);
var DEFAULT_ID = "floating-ui-root";
var FloatingPortal = (_ref) => {
  let {
    children,
    id = DEFAULT_ID
  } = _ref;
  const [mounted, setMounted] = (0, import_react2.useState)(false);
  const portalRef = (0, import_react2.useRef)(null);
  index(() => {
    const root = document.getElementById(id);
    if (root) {
      portalRef.current = root;
    } else {
      portalRef.current = document.createElement("div");
      portalRef.current.id = id;
    }
    const el = portalRef.current;
    if (!document.body.contains(el)) {
      document.body.appendChild(el);
    }
    setMounted(true);
  }, [id]);
  if (mounted && portalRef.current) {
    return (0, import_react_dom3.createPortal)(children, portalRef.current);
  }
  return null;
};
function _extends() {
  _extends = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
var identifier = "data-floating-ui-scroll-lock";
var FloatingOverlay = (0, import_react2.forwardRef)(function FloatingOverlay2(_ref, ref) {
  let {
    lockScroll = false,
    ...rest
  } = _ref;
  index(() => {
    if (!lockScroll) {
      return;
    }
    const scrollX = window.pageXOffset;
    const scrollY = window.pageYOffset;
    const scrollbarX = Math.round(document.documentElement.getBoundingClientRect().left) + document.documentElement.scrollLeft;
    const paddingProp = scrollbarX ? "paddingLeft" : "paddingRight";
    const scrollbarWidth = window.innerWidth - document.documentElement.clientWidth;
    const alreadyLocked = document.body.hasAttribute(identifier);
    if (alreadyLocked) {
      return;
    }
    Object.assign(document.body.style, {
      position: "fixed",
      overflow: "hidden",
      top: "-" + scrollY + "px",
      left: "-" + scrollX + "px",
      right: "0",
      [paddingProp]: scrollbarWidth + "px"
    });
    document.body.setAttribute(identifier, "");
    return () => {
      Object.assign(document.body.style, {
        position: "",
        overflow: "",
        top: "",
        left: "",
        right: "",
        [paddingProp]: ""
      });
      document.body.removeAttribute(identifier);
      window.scrollTo(scrollX, scrollY);
    };
  }, [lockScroll]);
  return import_react2.default.createElement("div", _extends({
    ref
  }, rest, {
    style: {
      position: "fixed",
      overflow: "auto",
      top: 0,
      right: 0,
      bottom: 0,
      left: 0,
      ...rest.style
    }
  }));
});
var FocusGuard = (0, import_react2.forwardRef)(function FocusGuard2(props, ref) {
  return import_react2.default.createElement("span", _extends({}, props, {
    ref,
    tabIndex: 0,
    style: {
      position: "fixed",
      opacity: "0",
      pointerEvents: "none",
      outline: "0"
    }
  }));
});
var FloatingDelayGroupContext = (0, import_react2.createContext)({
  delay: 1e3,
  initialDelay: 1e3,
  currentId: null,
  setCurrentId: () => {
  },
  setState: () => {
  }
});

// node_modules/htm/react/index.module.js
var import_react3 = __toESM(require_react());

// node_modules/htm/dist/htm.module.js
var n = function(t2, s, r2, e) {
  var u;
  s[0] = 0;
  for (var h = 1; h < s.length; h++) {
    var p = s[h++], a = s[h] ? (s[0] |= p ? 1 : 2, r2[s[h++]]) : s[++h];
    3 === p ? e[0] = a : 4 === p ? e[1] = Object.assign(e[1] || {}, a) : 5 === p ? (e[1] = e[1] || {})[s[++h]] = a : 6 === p ? e[1][s[++h]] += a + "" : p ? (u = t2.apply(a, n(t2, a, r2, ["", null])), e.push(u), a[0] ? s[0] |= 2 : (s[h - 2] = 0, s[h] = u)) : e.push(a);
  }
  return e;
};
var t = /* @__PURE__ */ new Map();
function htm_module_default(s) {
  var r2 = t.get(this);
  return r2 || (r2 = /* @__PURE__ */ new Map(), t.set(this, r2)), (r2 = n(this, r2.get(s) || (r2.set(s, r2 = (function(n2) {
    for (var t2, s2, r3 = 1, e = "", u = "", h = [0], p = function(n3) {
      1 === r3 && (n3 || (e = e.replace(/^\s*\n\s*|\s*\n\s*$/g, ""))) ? h.push(0, n3, e) : 3 === r3 && (n3 || e) ? (h.push(3, n3, e), r3 = 2) : 2 === r3 && "..." === e && n3 ? h.push(4, n3, 0) : 2 === r3 && e && !n3 ? h.push(5, 0, true, e) : r3 >= 5 && ((e || !n3 && 5 === r3) && (h.push(r3, 0, e, s2), r3 = 6), n3 && (h.push(r3, n3, 0, s2), r3 = 6)), e = "";
    }, a = 0; a < n2.length; a++) {
      a && (1 === r3 && p(), p(a));
      for (var l = 0; l < n2[a].length; l++) t2 = n2[a][l], 1 === r3 ? "<" === t2 ? (p(), h = [h], r3 = 3) : e += t2 : 4 === r3 ? "--" === e && ">" === t2 ? (r3 = 1, e = "") : e = t2 + e[0] : u ? t2 === u ? u = "" : e += t2 : '"' === t2 || "'" === t2 ? u = t2 : ">" === t2 ? (p(), r3 = 1) : r3 && ("=" === t2 ? (r3 = 5, s2 = e, e = "") : "/" === t2 && (r3 < 5 || ">" === n2[a][l + 1]) ? (p(), 3 === r3 && (h = h[0]), r3 = h, (h = h[0]).push(2, 0, r3), r3 = 0) : " " === t2 || "	" === t2 || "\n" === t2 || "\r" === t2 ? (p(), r3 = 2) : e += t2), 3 === r3 && "!--" === e && (r3 = 4, h = h[0]);
    }
    return p(), h;
  })(s)), r2), arguments, [])).length > 1 ? r2 : r2[0];
}

// node_modules/htm/react/index.module.js
var o = htm_module_default.bind(import_react3.createElement);

// node_modules/vibe-kanban-web-companion/src/VibeKanbanWebCompanion.js
var React2 = __toESM(require_react(), 1);

// node_modules/vibe-kanban-web-companion/src/getDisplayNameFromReactInstance.js
function getDisplayNameForInstance(instance) {
  const { elementType, tag } = instance;
  switch (tag) {
    case 0:
    // FunctionComponent
    case 1:
      return elementType.displayName || elementType.name || "Anonymous Component";
    case 3:
      return "HostRoot";
    case 4:
      return "HostPortal";
    case 5:
      return elementType;
    case 6:
      return "String";
    case 7:
      return "React.Fragment";
    case 8:
      return "Mode";
    case 9:
      return "Context.Consumer";
    case 10:
      return "Context.Provider";
    case 11:
      return "React.forwardRef";
    case 12:
      return "Profiler";
    case 13:
      return "SuspenseComponent";
    case 14:
      return "MemoComponent";
    case 15:
      return elementType.type.name ?? "MemoComponent";
    case 16:
      return "React.lazy";
    case 17:
      return "IncompleteClassComponent";
    case 18:
      return "DehydratedFragment";
    case 19:
      return "SuspenseListComponent";
    case 21:
      return "ScopeComponent";
    case 22:
      return "OffscreenComponent";
    case 23:
      return "LegacyHiddenComponent";
    case 24:
      return "CacheComponent";
    // @ts-expect-error Type '25' is not comparable to type 'WorkTag'.ts(2678)
    case 25:
      return "TracingMarkerComponent";
    // @ts-expect-error Type '26' is not comparable to type 'WorkTag'.ts(2678)
    case 26:
      return "HostHoistable";
    // @ts-expect-error Type '27' is not comparable to type 'WorkTag'.ts(2678)
    case 27:
      return "HostSingleton";
    // @ts-expect-error Type '28' is not comparable to type 'WorkTag'.ts(2678)
    case 28:
      return "IncompleteFunctionComponent";
    // @ts-expect-error Type '29' is not comparable to type 'WorkTag'.ts(2678)
    case 29:
      return "Throw";
    default:
      console.warn(`Unrecognized React Fiber tag: ${tag}`, instance);
      return "Unknown Component";
  }
}

// node_modules/vibe-kanban-web-companion/src/getPathToSource.js
function getPathToSource(source, pathModifier) {
  const {
    // It _does_ exist!
    // @ts-ignore Property 'columnNumber' does not exist on type 'Source'.ts(2339)
    columnNumber = 1,
    fileName,
    lineNumber = 1
  } = source;
  let path = `${fileName}:${lineNumber}:${columnNumber}`;
  if (pathModifier) {
    path = pathModifier(path);
  }
  return path;
}

// node_modules/vibe-kanban-web-companion/src/getPropsForInstance.js
function getPropsForInstance(instance) {
  const props = {};
  Object.entries(instance.memoizedProps).forEach(([key, value]) => {
    const type = typeof value;
    if (["key"].includes(key) || value === instance.type.defaultProps?.[key]) {
      return;
    }
    if (["string", "number", "boolean", "symbol"].includes(type) || value instanceof String || value instanceof Number || value instanceof Boolean || value instanceof Symbol) {
      props[key] = value;
    }
  });
  return props;
}

// node_modules/vibe-kanban-web-companion/src/getReactInstanceForElement.js
function getReactInstanceForElement(element) {
  if ("__REACT_DEVTOOLS_GLOBAL_HOOK__" in window) {
    const { renderers } = window.__REACT_DEVTOOLS_GLOBAL_HOOK__;
    for (const renderer of renderers.values()) {
      try {
        const fiber = renderer.findFiberByHostInstance(element);
        if (fiber) {
          return fiber;
        }
      } catch (e) {
      }
    }
  }
  if ("_reactRootContainer" in element) {
    return element._reactRootContainer._internalRoot.current.child;
  }
  for (const key in element) {
    if (key.startsWith("__reactInternalInstance$")) {
      return element[key];
    }
    if (key.startsWith("__reactFiber")) {
      return element[key];
    }
  }
}

// node_modules/vibe-kanban-web-companion/src/getReactInstancesForElement.js
function getReactInstancesForElement(element) {
  const instances = /* @__PURE__ */ new Set();
  let instance = getReactInstanceForElement(element);
  while (instance) {
    instances.add(instance);
    instance = instance._debugOwner;
  }
  return Array.from(instances);
}

// node_modules/vibe-kanban-web-companion/src/getSourceForInstance.js
function getSourceForInstance(instance) {
  if (!instance._debugSource) {
    return;
  }
  const {
    // It _does_ exist!
    // @ts-ignore Property 'columnNumber' does not exist on type 'Source'.ts(2339)
    columnNumber = 1,
    fileName,
    lineNumber = 1
  } = instance._debugSource;
  return { columnNumber, fileName, lineNumber };
}

// node_modules/vibe-kanban-web-companion/src/getUrl.js
function getUrl({ editor, pathToSource }) {
  if (pathToSource[0] === "/") {
    return `${editor}://file${pathToSource}`;
  }
  return `${editor}://file/${pathToSource}`;
}

// node_modules/vibe-kanban-web-companion/src/VibeKanbanWebCompanion.js
var State = (
  /** @type {const} */
  {
    IDLE: "IDLE",
    HOVER: "HOVER",
    SELECT: "SELECT"
  }
);
var Trigger = (
  /** @type {const} */
  {
    ALT_KEY: "alt-key",
    BUTTON: "button"
  }
);
var MESSAGE_SOURCE = "click-to-component";
var MESSAGE_VERSION = 1;
function getComponentInstances(target, pathModifier) {
  if (!target) return [];
  const instances = getReactInstancesForElement(target).filter(
    (instance) => getSourceForInstance(instance)
  );
  return instances.map((instance) => {
    const name = getDisplayNameForInstance(instance);
    const source = getSourceForInstance(instance);
    const path = getPathToSource(source, pathModifier);
    const props = getPropsForInstance(instance);
    return {
      name,
      props,
      source: {
        fileName: source.fileName,
        lineNumber: source.lineNumber,
        columnNumber: source.columnNumber
      },
      pathToSource: path
    };
  });
}
function postOpenToParent({ editor, pathToSource, url, trigger, event, element, pathModifier, selectedComponent }) {
  try {
    const el = element || (event && event.target instanceof HTMLElement ? event.target : null);
    const allComponents = el ? getComponentInstances(el, pathModifier) : [];
    const selected = selectedComponent ? allComponents.find((comp) => comp.name === selectedComponent) : allComponents.find((comp) => comp.pathToSource === pathToSource) || allComponents[0];
    const elementInfo = el ? {
      tag: el.tagName?.toLowerCase?.() || void 0,
      id: el.id || void 0,
      className: typeof el.className === "string" ? el.className : String(el.className || ""),
      role: el.getAttribute("role") || void 0,
      dataset: { ...el.dataset }
    } : void 0;
    const message = {
      source: MESSAGE_SOURCE,
      version: MESSAGE_VERSION,
      type: "open-in-editor",
      payload: {
        selected: selected ? {
          editor,
          pathToSource: selected.pathToSource,
          url,
          name: selected.name,
          props: selected.props,
          source: selected.source
        } : {
          editor,
          pathToSource,
          url,
          name: selectedComponent || "Unknown",
          props: {},
          source: {}
        },
        components: allComponents,
        trigger,
        coords: event ? { x: event.clientX ?? void 0, y: event.clientY ?? void 0 } : void 0,
        clickedElement: elementInfo
      }
    };
    if (typeof window !== "undefined" && window.parent && window.parent !== window && typeof window.parent.postMessage === "function") {
      window.parent.postMessage(message, "*");
    }
  } catch (err) {
    console.warn("[click-to-component] postMessage failed", err);
  }
}
function VibeKanbanWebCompanion() {
  const editor = "vscode";
  const pathModifier = (path) => path;
  const [state, setState] = React2.useState(
    /** @type {State[keyof State]} */
    State.IDLE
  );
  const [trigger, setTrigger] = React2.useState(
    /** @type {Trigger[keyof Trigger] | null} */
    null
  );
  const [target, setTarget] = React2.useState(
    /** @type {HTMLElement | null} */
    null
  );
  const [isFramed, setIsFramed] = React2.useState(false);
  const vkIcon = `<svg width="435" height="257" viewBox="0 0 435 257" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M51.4385 19.4795H68.8164V136.314H76.6152V155.719H93.9932V181.729H126.59V136.314H151.766V0.0751953H202.498V19.4795H219.876V165.677H194.699V211.091H169.522V256.505H58.8584V229.616H51.0596V211.091H33.6816V184.201H25.8828V165.677H8.50488V138.788H0.707031V0.0751953H51.4385V19.4795ZM291.169 19.4795H308.548V90.9014H341.143V45.4883H366.319V0.0751953H417.051V19.4795H434.43V74.8506H409.253V120.264H384.077V136.314H391.874V155.719H409.253V181.729H417.051V201.133H434.43V256.505H374.12V229.616H366.319V184.201H341.143V165.677H308.548V256.505H248.235V229.616H240.438V0.0751953H291.169V19.4795ZM202.498 26.0293H213.326V159.127H188.149V204.541H162.973V249.954H65.4082V229.616H62.2666V253.094H166.114V207.683H191.291V162.27H216.468V22.8877H202.498V26.0293ZM301.998 249.954H254.785V229.616H251.644V253.094H305.137V162.27H341.143V159.127H301.998V249.954ZM417.051 207.683H427.88V249.954H380.67V229.616H377.527V253.094H431.022V204.541H417.051V207.683ZM202.498 138.788H177.321V184.201H152.145V229.616H68.8164V246.544H159.564V201.133H184.741V155.719H209.918V29.4375H202.498V138.788ZM291.169 229.616H258.194V246.544H298.589V155.719H341.143V138.788H291.169V229.616ZM417.051 229.616H384.077V246.544H424.473V211.091H417.051V229.616ZM37.0898 207.683H51.0596V204.541H40.2324V184.201H37.0898V207.683ZM43.6396 201.133H51.0596V184.201H43.6396V201.133ZM76.6152 181.729H84.0352V165.677H76.6152V181.729ZM76.6152 162.27H87.4434V181.729H90.585V159.127H76.6152V162.27ZM391.874 181.729H399.297V165.677H391.874V181.729ZM391.874 162.27H402.703V181.729H405.847V159.127H391.874V162.27ZM11.9131 162.27H25.8828V159.127H15.0547V138.788H11.9131V162.27ZM18.4639 155.719H25.8828V138.788H18.4639V155.719ZM51.4385 136.314H58.8584V29.4375H51.4385V136.314ZM51.4385 26.0293H62.2666V136.314H65.4082V22.8877H51.4385V26.0293ZM417.051 47.9609H391.874V93.375H366.697V136.314H374.12V110.306H399.297V64.8926H424.473V29.4375H417.051V47.9609ZM417.051 26.0293H427.88V68.3008H402.703V113.714H377.527V136.314H380.67V116.855H405.847V71.4424H431.022V22.8877H417.051V26.0293ZM291.169 90.9014H298.589V29.4375H291.169V90.9014ZM291.169 26.0293H301.998V90.9014H305.137V22.8877H291.169V26.0293Z" fill="black"/>
</svg>`;
  const TargetButton = React2.useCallback(
    ({ active, onToggle }) => o`
      <button
        onClick=${function handleButtonClick(e) {
      e.stopPropagation();
      onToggle();
    }}
        aria-pressed=${active}
        style=${{
      position: "fixed",
      bottom: "16px",
      right: "16px",
      width: "48px",
      height: "48px",
      borderRadius: "50%",
      background: active ? "royalblue" : "white",
      color: active ? "white" : "black",
      border: "1px solid #ccc",
      boxShadow: "0 2px 6px rgba(0,0,0,.3)",
      zIndex: 2147483647,
      cursor: "pointer",
      fontSize: "18px",
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      padding: "8px"
    }}
        title="Toggle targeting mode"
      >
        <img
          src=${"data:image/svg+xml;utf8," + encodeURIComponent(vkIcon)}
          alt="VK Icon"
          style=${{
      width: "32px",
      height: "32px",
      filter: active ? "brightness(0) invert(1)" : "none"
    }}
        />
      </button>
    `,
    []
  );
  const toggleTargeting = React2.useCallback(() => {
    if (state === State.HOVER && trigger === Trigger.BUTTON) {
      setState(State.IDLE);
      setTrigger(null);
    } else {
      setState(State.HOVER);
      setTrigger(Trigger.BUTTON);
    }
  }, [state, trigger]);
  const onContextMenu = React2.useCallback(
    function handleContextMenu(event) {
      if (state !== State.IDLE && event.target instanceof HTMLElement) {
        event.preventDefault();
        postOpenToParent({
          editor,
          pathToSource: "",
          url: "",
          trigger: "context-menu",
          event,
          element: event.target,
          pathModifier
        });
      }
    },
    [state, editor, pathModifier]
  );
  const onClick = React2.useCallback(
    function handleClick(event) {
      if (state === State.HOVER) {
        event.preventDefault();
        event.stopPropagation();
      }
      if (state === State.HOVER && trigger === Trigger.BUTTON && target instanceof HTMLElement) {
        postOpenToParent({
          editor,
          pathToSource: "",
          // Will be determined when user selects
          url: "",
          trigger: "context-menu",
          event,
          element: target,
          pathModifier
        });
        setState(State.IDLE);
        setTrigger(null);
        return;
      }
      if (state === State.HOVER && trigger === Trigger.ALT_KEY && target instanceof HTMLElement) {
        const instance = getReactInstancesForElement(target).find(
          (instance2) => getSourceForInstance(instance2)
        );
        if (!instance) {
          return console.warn(
            "Could not find React instance for element",
            target
          );
        }
        const source = getSourceForInstance(instance);
        if (!source) {
          return console.warn(
            "Could not find source for React instance",
            instance
          );
        }
        const path = getPathToSource(source, pathModifier);
        const url = getUrl({
          editor,
          pathToSource: path
        });
        event.preventDefault();
        postOpenToParent({
          editor,
          pathToSource: path,
          url,
          trigger: "alt-click",
          event,
          element: target,
          pathModifier
        });
        setState(State.IDLE);
        setTrigger(null);
      }
    },
    [editor, pathModifier, state, trigger, target]
  );
  const onKeyDown = React2.useCallback(
    function handleKeyDown(event) {
      switch (state) {
        case State.IDLE:
          if (event.altKey) {
            setState(State.HOVER);
            setTrigger(Trigger.ALT_KEY);
          }
          break;
        case State.HOVER:
          if (event.key === "Escape" && trigger === Trigger.BUTTON) {
            setState(State.IDLE);
            setTrigger(null);
          }
          break;
        default:
      }
    },
    [state, trigger]
  );
  const onKeyUp = React2.useCallback(
    function handleKeyUp(event) {
      switch (state) {
        case State.HOVER:
          if (trigger === Trigger.ALT_KEY) {
            setState(State.IDLE);
            setTrigger(null);
          }
          break;
        default:
      }
    },
    [state, trigger]
  );
  const onMouseMove = React2.useCallback(
    function handleMouseMove(event) {
      if (!(event.target instanceof HTMLElement)) {
        return;
      }
      switch (state) {
        case State.IDLE:
        case State.HOVER:
          setTarget(event.target);
          break;
        default:
          break;
      }
    },
    [state]
  );
  const onBlur = React2.useCallback(
    function handleBlur() {
      switch (state) {
        case State.HOVER:
          setState(State.IDLE);
          setTrigger(null);
          break;
        default:
      }
    },
    [state]
  );
  React2.useEffect(
    function toggleIndicator() {
      for (const element of Array.from(
        document.querySelectorAll("[data-click-to-component-target]")
      )) {
        if (element instanceof HTMLElement) {
          delete element.dataset.clickToComponentTarget;
        }
      }
      if (state === State.IDLE) {
        delete window.document.body.dataset.clickToComponent;
        window.document.body.style.removeProperty("--click-to-component-cursor");
        if (target) {
          delete target.dataset.clickToComponentTarget;
        }
        return;
      }
      if (target instanceof HTMLElement) {
        window.document.body.dataset.clickToComponent = state;
        target.dataset.clickToComponentTarget = state;
        window.document.body.style.setProperty(
          "--click-to-component-cursor",
          "crosshair"
        );
      }
    },
    [state, target, trigger]
  );
  React2.useEffect(function detectIframe() {
    if (typeof window === "undefined") return;
    try {
      setIsFramed(window.self !== window.top);
    } catch {
      setIsFramed(true);
    }
  }, []);
  React2.useEffect(function sendReadyMessage() {
    if (typeof window !== "undefined" && window.parent && window.parent !== window && typeof window.parent.postMessage === "function") {
      try {
        window.parent.postMessage(
          {
            source: MESSAGE_SOURCE,
            version: MESSAGE_VERSION,
            type: "ready"
          },
          "*"
        );
      } catch (err) {
        console.warn("[click-to-component] ready message failed", err);
      }
    }
  }, []);
  React2.useEffect(
    function addEventListenersToWindow() {
      window.addEventListener("click", onClick, { capture: true });
      window.addEventListener("contextmenu", onContextMenu, { capture: true });
      window.addEventListener("keydown", onKeyDown);
      window.addEventListener("keyup", onKeyUp);
      window.addEventListener("mousemove", onMouseMove);
      window.addEventListener("blur", onBlur);
      return function removeEventListenersFromWindow() {
        window.removeEventListener("click", onClick, { capture: true });
        window.removeEventListener("contextmenu", onContextMenu, {
          capture: true
        });
        window.removeEventListener("keydown", onKeyDown);
        window.removeEventListener("keyup", onKeyUp);
        window.removeEventListener("mousemove", onMouseMove);
        window.removeEventListener("blur", onBlur);
      };
    },
    [onClick, onContextMenu, onKeyDown, onKeyUp, onMouseMove, onBlur]
  );
  return o`
    <style key="click-to-component-style">
      [data-click-to-component] * {
        pointer-events: auto !important;
      }

      [data-click-to-component-target] {
        cursor: var(--click-to-component-cursor, crosshair) !important;
        outline: auto 1px;
        outline: var(
          --click-to-component-outline,
          -webkit-focus-ring-color auto 1px
        ) !important;
      }
    </style>

    ${isFramed && o`
      <${FloatingPortal} key="click-to-component-portal">
        <${TargetButton}
          key="click-to-component-target-button"
          active=${state === State.HOVER && trigger === Trigger.BUTTON}
          onToggle=${toggleTargeting}
        />
      </${FloatingPortal}>
    `}
  `;
}

// node_modules/vibe-kanban-web-companion/src/index.js
var VibeKanbanWebCompanion2 = true ? VibeKanbanWebCompanion : () => null;
export {
  VibeKanbanWebCompanion2 as VibeKanbanWebCompanion
};
//# sourceMappingURL=vibe-kanban-web-companion.js.map
